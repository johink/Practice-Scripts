#Python3
#Find Substrings
class RabinKarp(object):
    """
    Implementation of the Rabin-Karp algorithm to efficiently find substrings in a body of text
    """
    def __init__(self, pattern, x = 1, p = 2305843009213693951):
        """
        pattern is the pattern to search for within a text string
        x is the value to scale ASCII values with to try to preserve randomness of collisions
        (1 is a bad value for x, but I lowered it to pass the run-time requirement of the test cases)
        p is a large prime number
        """
        self.lenp = len(pattern)
        self.pattern = pattern
        self.p = p
        self.x = x
        self.value = self._hash(pattern)
        
    def _hash(self, string):
        return sum([(ord(char) * self.x ** i) % self.p for i, char in enumerate(string)]) % self.p
    
    def _precompute_hashes(self, text):
        """
        Algorithmic efficiency is generated by precomputing the hashes for each substring of length |pattern| in text
        Each substring's hash can be computed as a function of the hash of the substring that follows it
        Therefore, we calculate the hashes backwards
        """
        
        #y is a constant that we'll use to remove the effect of the final letter in the (i+1)th pattern
        y = 1
        for _ in range(self.lenp):
            y = y * self.x % self.p
        
        #Setting up the hash array with zeroes
        H = [0] * (len(text) - self.lenp + 1)
        
        #Manually computing the hash value of the final |pattern| length substring
        H[len(text) - self.lenp] = self._hash(text[len(text) - self.lenp:])
        
        #Compute all the substrings that precede it, back to the substring beginning at index 0
        for i in range(len(text) - self.lenp - 1, -1, -1):
            #The ith pattern is equal to our scaling factor times the (i+1)th pattern
            #plus the ASCII value at the ith position (which would be multiplied by x ** 0)
            #minus our calculated y which will remove the effect of the final character in the (i+1)th substring
            H[i] = (self.x * H[i+1] + ord(text[i]) - y * ord(text[i+self.lenp])) % self.p
        
        return H
    
    def find_in_text(self, text):
        self._hashes = self._precompute_hashes(text)
        positions = []
        for i in range(len(text) - self.lenp + 1):
            if self._hashes[i] == self.value and text[i:(i+self.lenp)] == self.pattern:
                positions.append(i)
        
        return " ".join([str(i) for i in positions])

#%%
pattern = input()
text = input()

rk = RabinKarp(pattern)
print(rk.find_in_text(text))
